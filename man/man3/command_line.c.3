.TH "/media/solidity/DATA/Code/bonedaddy/c-template/src/utils/command_line.c" 3 "Thu Jul 9 2020" "c-template" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/media/solidity/DATA/Code/bonedaddy/c-template/src/utils/command_line.c
.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <argtable3\&.h>\fP
.br
\fC#include '\&.\&./\&.\&./include/utils/colors\&.h'\fP
.br
\fC#include '\&.\&./\&.\&./include/utils/command_line\&.h'\fP
.br
\fC#include '\&.\&./\&.\&./include/utils/array_len\&.h'\fP
.br
\fC#include '\&.\&./\&.\&./include/utils/logger\&.h'\fP
.br
\fC#include '\&.\&./\&.\&./include/utils/safe_mem\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBcommand_object\fP * \fBnew_command_object\fP (int argc, char *argv[])"
.br
.RI "intializes a new command_object to have commands loaded into "
.ti -1c
.RI "int \fBload_command\fP (\fBcommand_object\fP *self, \fBcommand_handler\fP *\fBcommand\fP)"
.br
.RI "loads command handler and makes it executable "
.ti -1c
.RI "int \fBexecute\fP (\fBcommand_object\fP *self, char *run)"
.br
.RI "checks to see if we have a command named according to run and executes it "
.ti -1c
.RI "void \fBfree_command_object\fP (\fBcommand_object\fP *self)"
.br
.RI "frees memory allocated for the command_object and sets pointer to null for some reason this is causing an address boundary error "
.ti -1c
.RI "int \fBparse_args\fP (int argc, char *argv[], void *argtable[])"
.br
.RI "parses arguments, and checks for any errors "
.ti -1c
.RI "void \fBprint_help\fP (char *program_name, void *argtable[])"
.br
.RI "formats output "
.ti -1c
.RI "void \fBsetup_args\fP (const char *version_string)"
.br
.RI "setups the default argtable arguments "
.ti -1c
.RI "char * \fBget_run_command\fP ()"
.br
.RI "returns the value of command_to_run "
.in -1c
.SH "Function Documentation"
.PP 
.SS "int execute (\fBcommand_object\fP * self, char * run)"

.PP
checks to see if we have a command named according to run and executes it 
.PP
Definition at line 59 of file command_line\&.c\&.
.SS "void free_command_object (\fBcommand_object\fP * self)"

.PP
frees memory allocated for the command_object and sets pointer to null for some reason this is causing an address boundary error frees memory allocated for the command_object and sets pointer to null 
.PP
Definition at line 74 of file command_line\&.c\&.
.SS "char* get_run_command ()"

.PP
returns the value of command_to_run 
.PP
Definition at line 115 of file command_line\&.c\&.
.SS "int load_command (\fBcommand_object\fP * self, \fBcommand_handler\fP * command)"

.PP
loads command handler and makes it executable 
.PP
Definition at line 47 of file command_line\&.c\&.
.SS "\fBcommand_object\fP* new_command_object (int argc, char * argv[])"

.PP
intializes a new command_object to have commands loaded into 
.PP
Definition at line 14 of file command_line\&.c\&.
.SS "int parse_args (int argc, char * argv[], void * argtable[])"

.PP
parses arguments, and checks for any errors 
.PP
Definition at line 82 of file command_line\&.c\&.
.SS "void print_help (char * program_name, void * argtable[])"

.PP
formats output 
.PP
Definition at line 99 of file command_line\&.c\&.
.SS "void setup_args (const char * version_string)"

.PP
setups the default argtable arguments 
.PP
Definition at line 106 of file command_line\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for c-template from the source code\&.
