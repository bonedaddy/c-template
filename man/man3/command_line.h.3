.TH "/media/solidity/DATA/Code/bonedaddy/c-template/include/utils/command_line.h" 3 "Thu Jul 9 2020" "c-template" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/media/solidity/DATA/Code/bonedaddy/c-template/include/utils/command_line.h \- provides a basic CLI building tool attribution note: modified version of commander see \fCdeps/commander\fP for the license for that package uses argtable3 for command line configuration and allows loading a list of commands to execute using the \fC--conmmand\fP or \fC-c\fP CLI flag you can specify the command out of the list of commands that have been loaded before calling execute you'll want to load the appropriate \fCargc\fP and \fCargv\fP values for the callback of the command you want to make  

.SH SYNOPSIS
.br
.PP
\fC#include <argtable3\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBcommand_handler\fP"
.br
.ti -1c
.RI "struct \fBcommand\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMAX_COMMANDS\fP   32"
.br
.ti -1c
.RI "#define \fBMAX_COMMAND_ARGS\fP   32"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBcommand_handler_callback\fP) (int argc, char *argv[])"
.br
.ti -1c
.RI "typedef struct \fBcommand\fP \fBcommand_object\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBget_run_command\fP ()"
.br
.RI "returns the value of command_to_run "
.ti -1c
.RI "void \fBsetup_args\fP (const char *version_string)"
.br
.RI "setups the default argtable arguments "
.ti -1c
.RI "void \fBprint_help\fP (char *program_name, void *argtable[])"
.br
.RI "formats output "
.ti -1c
.RI "int \fBparse_args\fP (int argc, char *argv[], void *argtable[])"
.br
.RI "parses arguments, and checks for any errors "
.ti -1c
.RI "int \fBexecute\fP (\fBcommand_object\fP *self, char *\fBcommand_to_run\fP)"
.br
.RI "checks to see if we have a command named according to run and executes it "
.ti -1c
.RI "int \fBload_command\fP (\fBcommand_object\fP *self, \fBcommand_handler\fP *\fBcommand\fP)"
.br
.RI "loads command handler and makes it executable "
.ti -1c
.RI "\fBcommand_object\fP * \fBnew_command_object\fP (int argc, char *argv[])"
.br
.RI "intializes a new command_object to have commands loaded into "
.ti -1c
.RI "void \fBfree_command_object\fP (\fBcommand_object\fP *self)"
.br
.RI "frees memory allocated for the command_object and sets pointer to null "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct arg_lit * \fBhelp\fP"
.br
.ti -1c
.RI "struct arg_lit * \fBversion\fP"
.br
.ti -1c
.RI "struct arg_str * \fBcommand_to_run\fP"
.br
.ti -1c
.RI "struct arg_file * \fBfile\fP"
.br
.ti -1c
.RI "struct arg_file * \fBoutput\fP"
.br
.ti -1c
.RI "struct arg_end * \fBend\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
provides a basic CLI building tool attribution note: modified version of commander see \fCdeps/commander\fP for the license for that package uses argtable3 for command line configuration and allows loading a list of commands to execute using the \fC--conmmand\fP or \fC-c\fP CLI flag you can specify the command out of the list of commands that have been loaded before calling execute you'll want to load the appropriate \fCargc\fP and \fCargv\fP values for the callback of the command you want to make 


.PP
Definition in file \fBcommand_line\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define MAX_COMMAND_ARGS   32"

.PP
Definition at line 22 of file command_line\&.h\&.
.SS "#define MAX_COMMANDS   32"

.PP
Definition at line 18 of file command_line\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* command_handler_callback) (int argc, char *argv[])"

.PP
Definition at line 35 of file command_line\&.h\&.
.SS "typedef struct \fBcommand\fP \fBcommand_object\fP"

.SH "Function Documentation"
.PP 
.SS "int execute (\fBcommand_object\fP * self, char * command_to_run)"

.PP
checks to see if we have a command named according to run and executes it 
.PP
Definition at line 59 of file command_line\&.c\&.
.SS "void free_command_object (\fBcommand_object\fP * self)"

.PP
frees memory allocated for the command_object and sets pointer to null frees memory allocated for the command_object and sets pointer to null 
.PP
Definition at line 74 of file command_line\&.c\&.
.SS "char* get_run_command ()"

.PP
returns the value of command_to_run 
.PP
Definition at line 115 of file command_line\&.c\&.
.SS "int load_command (\fBcommand_object\fP * self, \fBcommand_handler\fP * command)"

.PP
loads command handler and makes it executable 
.PP
Definition at line 47 of file command_line\&.c\&.
.SS "\fBcommand_object\fP* new_command_object (int argc, char * argv[])"

.PP
intializes a new command_object to have commands loaded into 
.PP
Definition at line 14 of file command_line\&.c\&.
.SS "int parse_args (int argc, char * argv[], void * argtable[])"

.PP
parses arguments, and checks for any errors 
.PP
Definition at line 82 of file command_line\&.c\&.
.SS "void print_help (char * program_name, void * argtable[])"

.PP
formats output 
.PP
Definition at line 99 of file command_line\&.c\&.
.SS "void setup_args (const char * version_string)"

.PP
setups the default argtable arguments 
.PP
Definition at line 106 of file command_line\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "struct arg_str* command_to_run"

.PP
Definition at line 27 of file command_line\&.h\&.
.SS "struct arg_end* end"

.PP
Definition at line 29 of file command_line\&.h\&.
.SS "struct arg_file* file"

.PP
Definition at line 28 of file command_line\&.h\&.
.SS "struct arg_lit* help"

.PP
Definition at line 26 of file command_line\&.h\&.
.SS "struct arg_file * output"

.PP
Definition at line 28 of file command_line\&.h\&.
.SS "struct arg_lit * version"

.PP
Definition at line 26 of file command_line\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for c-template from the source code\&.
